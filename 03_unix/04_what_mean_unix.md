---

### in / process / out という人間の基本構造

人の作業の多くは、突き詰めれば  
**in / process / out** の構造を持っている。

- in：材料・情報・入力
- process：考える・試す・組み替える
- out：結果・表現・判断材料

Word や Excel も、本来はこの構造に沿っている。  
何らかの入力があり、それを加工し、結果を得る。

しかし多くのGUIツールでは、  
process の部分がクリック操作の連続として消費される。

- どこをどう考えたか  
- なぜその操作を選んだか  
- 他の選択肢は何だったか  

それらは記録されず、  
結果だけがファイルとして残る。

マクロや関数で複雑な処理を行っても、  
時間が経てば「なぜそうなっているのか」は分からなくなる。  
そして再作成や作り直しが発生する。

---

### Unixが提示した解法 —— pipe と filter

Unixは、  
この **in / process / out** を隠さなかった。

- コマンドは入力を受け取る（in）
- 処理は単機能で明示される（process）
- 出力は次に渡せる形で返される（out）

その out を、次の in として渡す仕組みが  
**pipe（パイプ）と filter（フィルタ）**である。


この連結により、  
小さなコマンドの並びが  
ユーザの思考に沿って少しずつ形を変えていく。

正解を一発で当てる必要はない。

- 試す  
- 出力を見る  
- 少し変える  
- もう一度つなぐ  

この試行錯誤そのものが process として残り、  
やがて目的の out に近づいていく。

---

### process が残るという価値

Unixにおいて重要なのは、  
out そのものではない。

**そこに至る process が、  
そのまま再利用可能な形で残ること**に価値がある。

履歴、スクリプト、ワンライナーは、  
単なる操作記録ではない。

それは  
「こう考え、こう試し、こう修正した」  
という思考の保存である。

Unixが50年以上前に提示した pipe と filter は、  
人間が考え、試行錯誤し、修正するための  
極めて人間的な構造だった。

そしてそれは、  
いまなお有効な解法である。

